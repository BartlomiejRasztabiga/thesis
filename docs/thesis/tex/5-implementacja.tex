\clearpage % Rozdziały zaczynamy od nowej strony.

\section{Implementacja}

Rozdział ten ma na celu szczegółowy opis implementacji systemu. Zostaną w nim przedstawione wykorzystane narzędzia, podział na moduły oraz szczegóły implementacyjne. Swoje miejsce znajdą tutaj również fragmenty kodu źródłowego, które mają na celu ułatwić zrozumienie sposobu działania systemu.

\subsection{Część serwerowa}

Część serwerową systemu stanowi aplikacja o architekturze mikroserwisowej, napisana w języku Kotlin z wykorzystaniem frameworków Spring Boot oraz Axon Framework.

\subsubsection{Użyte narzędzia}

W części serwerowej aplikacji wykorzystano następujące najważniejsze narzędzia:

\textbf{Kotlin} \cite{kotlin} to język programowania stworzony przez firmę JetBrains, działający na maszynie wirtualnej Javy (JVM) \cite{jvm}. Kotlin jest językiem statycznie typowanym, który łączy w sobie cechy zarówno języków obiektowych, jak i funkcyjnych. Jest on kompilowany do kodu bajtowego Javy, a jego składnia jest w dużej mierze zgodna z Javą, co czyni go łatwym do nauki i zrozumienia dla programistów Javy. Kotlin jest językiem wieloplatformowym, co oznacza, że może być kompilowany do kodu bajtowego Javy, kodu bajtowego Javy na Androida, kodu JavaScript oraz kodu natywnego. Kotlin jest językiem ogólnego przeznaczenia, który może być wykorzystywany do tworzenia aplikacji webowych, mobilnych, desktopowych, a nawet do tworzenia skryptów. Jego jedną z ważniejszych zalet jest wprowadzenie nullowalności na poziomie systemu typów, co pozwala na wykrywanie błędów związanych z niepoprawnym użyciem wartości null w czasie kompilacji, a nie w czasie działania programu.

\textbf{Spring Boot} \cite{springboot} to framework w ekosystemie Spring, który ułatwia tworzenie i rozwijanie aplikacji webowych oraz mikroserwisów w językach Java i Kotlin. Spring Boot oferuje wsparcie dla mikroserwisów, ułatwiając ich tworzenie, testowanie i wdrażanie, co czyni go popularnym wyborem wśród programistów pracujących nad nowoczesnymi, skalowalnymi aplikacjami.

Spring Boot ma silne powiązanie z koncepcją "cloud native", która odnosi się do projektowania aplikacji specjalnie na potrzeby chmury. Spring Boot ułatwia tworzenie aplikacji mikroserwisowych, które są nieodzownym elementem architektury cloud native, dostarczając funkcjonalności takie jak łatwa integracja z kontenerami (np. Docker), obsługa konfiguracji zewnętrznej, zarządzanie usługami przez service discovery oraz wspieranie wzorców takich jak circuit breaker. Te cechy sprawiają, że Spring Boot jest idealnym wyborem dla tworzenia aplikacji przygotowanych do działania w środowiskach chmurowych, oferujących skalowalność, elastyczność i odporność.

\textbf{Axon Framework} to framework do tworzenia aplikacji w architekturze opartej na zdarzeniach (event-driven) i wzorcu CQRS. Wspiera również DDD, Event Sourcing oraz wzorzec Saga. Axon Framework jest napisany w języku Java, ale może być wykorzystywany również w języku Kotlin. Axon Framework dostarcza abstrakcje do tworzenia aplikacji opartych na zdarzeniach, takich jak agregaty, komendy, zdarzenia, szyna wiadomości, sagi, itp. Axon Framework jest narzędziem open source, rozwijanym przez firmę AxonIQ.

\textbf{Axon Server} jest infrastrukturalnym elementem ekosystemu Axon, pełniącym rolę kolejki komunikatów oraz magazynu zdarzeń. Oferuje on również narzędzia do monitoringu i zarządzania aplikacjami opartymi na Axon Framework.

\subsubsection{Architektura heksagonalna}

Część serwerowa aplikacji została zaimplementowana zgodnie z architekturą heksagonalną (ang. hexagonal architecture), która jest jedną z popularnych architektur aplikacji serwerowych, wykorzystywanych przy złożonych projektach informatycznych. Architektura ta jest również znana pod nazwą architektury czystej (ang. clean architecture) lub architektury portów i adapterów (ang. ports and adapters architecture). Została ona zaproponowana przez Alistaira Cockburna w 2005 roku \cite{cockburn2005hexagonal}.

Architektura heksagonalna jest architekturą warstwową, która składa się z trzech warstw: warstwy adapterów, warstwy dziedziny oraz warstwy infrastruktury. Warstwa dziedziny jest główną warstwą aplikacji, która zawiera logikę biznesową. Warstwa adapterów jest warstwą zewnętrzną, która zawiera adaptery wejściowe i wyjściowe, które są odpowiedzialne za komunikację z zewnętrznymi systemami. Warstwa infrastruktury jest warstwą wewnętrzną, która zawiera implementację adapterów wejściowych i wyjściowych. Warstwa infrastruktury jest odpowiedzialna za konfigurację aplikacji oraz za integrację z zewnętrznymi systemami (np. bazą danych, systemem plików, itp.).

\subsubsection{Podział na pakiety}

Z powodu zastosowania architektury heksagonalnej, część serwerowa aplikacji została podzielona na pakiety zgodnie z warstwami tejże architektury. Podział na pakiety przykładowego serwisu został przedstawiony na listingu \ref{lst:server-packages}.

\begin{lstlisting}[caption={Podział na pakiety części serwerowej projektu},label={lst:server-packages},captionpos=b]
- adapter/
    - in/
    - out/
- domain/
    - query/
    - command/
- config/
- infrastructure/
- Application.kt
\end{lstlisting}

W kolejnych podrozdziałach zostaną przedstawione szczegóły implementacyjne poszczególnych warstw wraz z ich opisem.

\subsubsection{Warstwa adapterów wejściowych} 

Warstwa ta obejmuje pakiet \textit{adapter.in}. Zawiera ona tzw. adaptery wejściowe, czyli komponenty odpowiedzialne za rozpoczynanie przepływu sterowania w aplikacji. Adaptery wejściowe są odpowiedzialne za obsługę zapytań i komend, które są wysyłane do aplikacji przez użytkowników lub inne systemy. W implementowanym systemie adapterami wejściowymi są kontrolery REST API oraz serwisy nasłuchujące na zdarzenia z kolejki komunikatów.

Na listingu \ref{lst:server-in-adapter} przedstawiono przykładowy kod kontrolera REST API, który obsługuje zapytanie HTTP POST na ścieżce \textit{/api/v1/orders}. Zapytanie to rozpoczyna zamówienie ze strony użytkownika zamawiającego. W ciele zapytania znajduje się obiekt JSON, który jest mapowany na obiekt klasy \textit{StartOrderRequest}. Obiekt ten jest następnie przekazywany do komponentu \textit{ReactorCommandGateway}, który jest odpowiedzialny za wysłanie komendy \textit{StartOrderCommand} do szyny komend. Komenda ta jest następnie przekazywana do odpowiedniego agregatu dziedzinowego, który jest odpowiedzialny za jej obsługę. Rezultatem synchronicznym obsługi komendy jest nadany identyfikator zamówienia, w postacu UUID, który jest zwracany w odpowiedzi HTTP. 

\begin{lstlisting}[caption={Przykładowy kod kontrolera REST API},label={lst:server-in-adapter},captionpos=b,language=Kotlin,numbers=left]
    @RestController
    @RequestMapping("/api/v1/orders")
    class OrderController(
        private val reactorCommandGateway: ReactorCommandGateway
    ) {
        @PostMapping
        @ResponseStatus(HttpStatus.CREATED)
        @PreAuthorize("hasAnyAuthority('${Scopes.ORDER.WRITE}')")
        fun startOrder(
            @RequestBody request: StartOrderRequest,
            exchange: ServerWebExchange
        ): Mono<UuidWrapper> {
            val command = mapToStartOrderCommand(request, exchange)
            val id = reactorCommandGateway.send<UUID>(command)
            return id.map { UuidWrapper(it) }
        }
    }
\end{lstlisting}

Kod kontrolera został napisany z wykorzystaniem biblioteki programowania reaktywnego Spring WebFlux, która pozwala na obsługę żądań HTTP w sposób asynchroniczny. Pozwala to na obsługę większej liczby żądań przy użyciu mniejszej liczby wątków, co przekłada się na większą wydajność aplikacji.

Poza kodem obsługującym żądanie HTTP, kontroler zawiera również adnotacje, które definiują uprawnienia wymagane do wykonania żądania. W tym przypadku żądanie wymaga posiadania uprawnień \textit{ORDER.WRITE}, które są zdefiniowane w klasie \textit{Scopes}. Jest to część biblioteki Spring Security, implementującej standard OAuth 2.0.

\subsubsection{Warstwa adapterów wyjściowych} 

Warstwa ta obejmuje pakiet \textit{adapter.out}. Zawiera ona tzw. adaptery wyjściowe, czyli komponenty odpowiedzialne za komunikację z zewnętrznymi systemami. W implementowanym systemie adapterami wyjściowymi są komponenty oferujące dostęp do bazy danych oraz komunikację z zewnętrznymi systemami np. Google Maps Platform.

Na listingu \ref{lst:server-out-adapter} przedstawiono przykładowy kod komponentu oferującego dostęp do bazy danych. Jest to implementacja (adapter) interfejsu (portu) \textit{OrderDeliveryRepository}, który jest odpowiedzialny za zapisywanie i odczytywanie encji \textit{OrderDeliveryEntity} z bazy danych. Implementacja ta wykorzystuje repozytorium Spring Data, które jest komponentem oferującym dostęp do bazy MongoDB. Repozytorium to jest wstrzykiwane do klasy \textit{DbOrderDeliveryRepository} przy pomocy mechanizmu wstrzykiwania zależności oferowanego przez framework Spring. 

\begin{lstlisting}[caption={Przykładowy kod implementacji repozytorium bazodanowego},label={lst:server-out-adapter},captionpos=b,language=Kotlin,numbers=left]
    @Service
    class DbOrderDeliveryRepository(
        private val repository: SpringDataOrderDeliveryRepository
    ) : OrderDeliveryRepository {
        override fun save(delivery: OrderDeliveryEntity) {
            repository.save(delivery).block()
        }
    
        override fun load(id: UUID): OrderDeliveryEntity? {
            return repository.findById(id).block()
        }
    
        override fun loadOffers(): List<OrderDeliveryEntity> {
            return repository
                .findAllByStatus(DeliveryStatus.OFFER)
                .collectList().block() ?: listOf()
        }
    }
\end{lstlisting}

\subsubsection{Warstwa dziedziny} 

Warstwa ta obejmuje pakiet \textit{domain}. Zawiera ona komponenty, które są odpowiedzialne za logikę biznesową aplikacji. W implementowanym systemie komponentami tymi są agregaty, komendy, zdarzenia, zapytania oraz obiekty transferu danych.

Warstwa dziedziny jest podzielona zgodnie ze wzorcem CQRS na część komend oraz część zapytań. Część komend jest zawarta w podpakiecie \textit{command}, a część zapytań w podpakiecie \textit{query}.

TODO inaczej zrefrazować

Na listingu \ref{lst:server-domain} przedstawiono przykładowy kod kilku komponentów części komend, odpowiedzialnych za obsługę operacji na zamówieniach.

TODO

TODO a moze podzielic ten listing na mniejsze?

TODO napisac ze to axon jest odpowiedzialny za wszystko poprzez adnotacje

\begin{lstlisting}[caption={Kod komponentów odpowiedzialnych za obsługę zamówień},label={lst:server-domain},captionpos=b,language=Kotlin,numbers=left]
    @Aggregate
    internal class Order {
    
        @AggregateIdentifier
        private lateinit var id: UUID
        private lateinit var status: OrderStatus
    
        @AggregateMember
        private val items: MutableMap<UUID, Int> = mutableMapOf()
    
        @CommandHandler
        constructor(
            command: StartOrderCommand,
            orderVerificationPort: OrderVerificationPort
        ) {
            require(
                orderVerificationPort.restaurantExists(command.restaurantId)
            ) {
                "Restaurant with id ${command.restaurantId} does not exist"
            }
            require(
                orderVerificationPort.isRestaurantOpen(command.restaurantId)
            ) {
                "Restaurant with id ${command.restaurantId} is closed"
            }
    
            apply(
                OrderStartedEvent(
                    orderId = command.orderId,
                    restaurantId = command.restaurantId,
                    userId = command.userId,
                    status = OrderStartedEvent.OrderStatus.CREATED
                )
            )
        }
    }

    data class StartOrderCommand(
        @TargetAggregateIdentifier val orderId: UUID,
        val userId: String,
        val restaurantId: UUID
    )

    data class OrderStartedEvent(
        val orderId: UUID,
        val restaurantId: UUID,
        val userId: String,
        val status: OrderStatus
    )

    interface OrderVerificationPort {

        fun restaurantExists(restaurantId: UUID): Boolean

        fun isRestaurantOpen(restaurantId: UUID): Boolean
    }

\end{lstlisting}


\subsubsection{Warstwa prezentacji/zapytań} domain/query

\subsubsection{Warstwa konfiguracji} config

\subsubsection{Warstwa infrastruktury} infrastructure

\subsubsection{Współdzielony kod}

Kod współdzielony przez różne serwisy w ramach systemu został umieszczony w osobnym module \textit{shared}. Zawiera on m.in. klasy reprezentujące obiekty transferu danych, wyjątki, stałe, wspólną konfigurację itp.

Moduł ten jest wersjonowany i publikowany jako artefakt systemu budowania Maven, dzięki czemu może być umieszczony w centralnym repozytorium i importowany przez inne projekty.

\subsection{Część kliencka}

Część kliencka aplikacji została zaimplementowana jako aplikacja przeglądarkowa typu Multi Page Application (MPA) w języku TypeScript z wykorzystaniem frameworków React oraz Remix.

TODO czemu nie SPA?

\subsubsection{Użyte narzędzia}

\subsubsection{Podział na katalogi}

\subsubsection{Komponenty interfejsu użytkownika}

\subsubsection{Komunikacja z częścią serwerową}

\subsubsection{Obsługa ścieżek}

\subsubsection{Współdzielony kod}

\subsubsection{Przechowywanie stanu aplikacji}